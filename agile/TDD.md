# 测试驱动开发 Test-Driven Development TDD

* 正确软件的开发套路
* 提高软件认知能力的方法
* 敏捷开发中的一项核心实践和技术，也是一种设计方法论
* 原理
  - 在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码
  - 分离关注点，一次只戴一顶帽子
  - 只在没有信心的地方写测试代码
  - 红：写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现
  - 绿：专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹
  - 重构：既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码
* 测试驱动开发是戴两顶帽子思考的开发方式
  - 先戴上实现功能的帽子，在测试的辅助下，快速实现其功能
  - 再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量
* 测试驱动着整个开发过程
  - 驱动代码的设计和功能的实现
  - 驱动代码的再设计和重构
* XP（Extreme Programming）的核心实践
* 优点
  - 降低开发者负担：通过明确的流程，让我们一次只关注一个点，思维负担更小
  - 保护网：TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。
  - 提前澄清需求：先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。
  - 快速反馈：有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处
  - 细化与澄清需求，分Task(Test Driver Business)
  - 分离关注点
  - 快速定位Bug,易于调试
  - 快速得到反馈，增加开发人员信心
  - 帮组系统的设计灵活、松耦合(Test Driver Design)
  - 可执行的以及永远最新的说明文档(Live Document)
  - 更少的回归测试,正确率提高.
  - 安全重构(经验值：80%)
* 重要的不是测试代码本身，是解决问题的思维:小步快跑，快速反馈，实现刚好，设计优美，价值优先，增量完美
* 三层含义
  - Test-Driven Development，测试驱动开发
  - Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解
  - Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，只是给更多机会和保障去改善设计
  - Testability Driven Design 可测试性驱动设计，在每一个小步、每一行代码都必须先考虑“怎么测”，可测试性是潜移默化地植根在软件整个建造过程中的，所以用TDD方法开发出来的软件具有极佳的可测试性，质量也自然地更可靠
* 测试具有业务价值，测试的粒度，测试即文档
* DD增加我们的信心，促进反馈周期，价值的稳定的叠加
* 重构是程序员的一项有利工具

## 分类

* UTDD Unit Test Driven Development 单元驱动测试开发
  - 首先编写单元测试用例，然后编写实现代码直到单元测试通过
* ATDD Acceptance Test-Driven Development 验收测试驱动开发
  - BA或者QA编写验收测试用例，然后Dev通过验收测试来理解需求和验收条件，并编写实现代码直到验收测试用例通过
  - 强调的也是需求的澄清，通过举例的手段对用户故事需求进行澄清，再接着让这些例子变成一个个的测试用例，在功能需求被实现后，用这些测试用例去验证功能实现是否满足需求，而这需求的澄清和测试用例的实现是前置在具体的开发实现之前的
  - 因为是通过举例的形式来描述功能的需求说明，也称之为SbE（Specification by Example，中文译为实例化需求），其同样要求测试前置
  - 可以比较着TDD的概念来理解，TDD是对函数级别的需求说明，再驱动实现，而ATDD是对用户故事的级别的需求说明，分析，再驱动实现，都要求测试前置，即关注WHAT
  - 测试自动化是一种缩短反馈周期，实现回归测试（Regression Test）的手段。结合着持续集成系统，可以实现一键自动化的集成与部署
  - BDD（Behavior Driven Development） 以软件的行为为验收标准
  - EDD（Example Driven Development） 以特定的实例数据为验收标准
  - FDD（Feature Driven Development）
  - CDCD（Consumer Driven Contract Development）以Web Service API消费者提出API契约来驱动API提供者开发API
* 单元测试：可以进行的最低级别的测试。通常是在类内部测试方法。单元测试不直接与其他类交互，而是与模拟交互。这使单元测试变得孤立，并且易于调试和重构
* 集成测试：涉及多个类别。因此，它测试了类之间的集成，即依赖关系。它用于测试数据库是否为我们提供了正确的结果，外部 API 是否为我们提供了正确的数据等。它用于测试实际的类和功能，而不是使用模拟。与运行的单元测试相比，它要慢得多，因为它们与数据库和外部提供程序进行交互
* 功能测试：一种测试整个功能的测试，可能需要很多依赖。通常，将测试路由以获取正确的响应，或者测试与应用程序中某些功能相关的 Controller 方法。它们比集成测试慢，因为它们涉及更多的依赖关系
* 验收测试：验收测试是最高级别的测试。只关心该功能是否可以通过客户的有利位置工作。测试流程通过网站单击并提交表格，并期望得到正确的结果。为此，我们使用了 Selenium 之类工具

## 需求设计

* 这个程序，打算怎么给人用呢？
* 软件功能：到底做什么，做到什么程度
  - 确认自己听到的需求，是不是真实、完整的需求
* 软件形态：考虑代码将会如何被使用
* 现象
  - 无视设计
  - 过度设计
* 敏捷，既不是做过度复杂的设计，也不是完全不做设计埋头就开始编码
  - 敏捷，既不是做过度复杂的设计，也不是完全不做设计埋头就开始编码
  - TDD 正是能够快速获得合理设计、并能迅速做出设计调整的能力

## 驱动力

* 设计接口是体现测试驱动开发“驱动力”的重要一点。之所以先编写测试，就是希望开发人员站在调用者和业务价值的角度去思考，即所谓“意图导向编程”。从调用的角度思考，可以驱动思考并达到如下目的：
  - 如何命名被测试类以及方法，才能更好地表达设计者的意图，使得测试具有更好的可读性；
  - 被测对象的创建必须简单，这样才符合测试哲学，从而使得设计具有良好的可测试性；
  - 测试使我们只关注接口，而非实现；

## 流程

* 需求分析
  - 协作需求梳理：澄清-》验收条件-》测试案例
  - Alice (actor) liked (verb) photo ... (object) on Cynthia's album (target). 从中抽取出四个要素：actor，verb，object，target(optional)，通过这四个要素，我们可以描述一个用户的行为
  - 系统组成
    + activity receive and persistence - 当一个行为产生后，外部系统会调用 news feed 来创建 activity；
    + feed generator - 当 activity 创建成功后，它会扩散到所有 subscribers 那里生成 feed；
    + subscription generator - 当 activity 是某种特定 verb 的 activity， 我们维护 object 的 subscription 表（添加/删除）
* 代码设计
  - 定义接口
  - interface review
  - 开发：需要不断地为更加细分的接口设计添加新的测试例
    + 用户级。对于很多项目来说，用户级的接口是 API。这里可能是 rest API，GraphQL，RPC，私有协议等等
    + app级。注意，这里说的 app 并非指一个单独的应用程序，而是逻辑上的概念。一个系统可以逻辑上分解成若干个内部的 app，它们互相作用，最后构成了这个系统。app 间如何互相调用，非常重要。
    + 模块级。我们只需要关心模块的公共接口。私有接口无所谓。
    + 对系统中不确定的，或者变化大的部分，不要引入过多的 case，而对于系统中确定的，或者接口已经发展稳定地部分，不妨把 TDD 延伸到模块级。
  - 分层
    + 把顶层的，用户级别的接口放在一个目录下，app 级别的按 app 名放在不同的子目录，模块级的按模块名放在不同的子目录，不要混在一起。用户级别的接口应该是最稳定的，添加新接口无妨，但是如果已有的接口要改变，我们需要从中分析原因并吸取经验
      * 是需求分析出了岔子，没有明确完整的需求？
      * 是接口设计阶段考虑的不够周全？
      * 是设计水平不够，导致接口不够对变化开放？
* 先分解任务，分离关注点:开卡、验卡，实现验收测试、
  - 确定测试实例化最关键：保证对业务理解一致
* 列 Example，用实例化需求，澄清需求细节
* 写测试，只关注需求，程序的输入输出，不关心中间过程
* 写实现，不考虑别的需求，用最简单的方式满足当前这个小需求即可,方式：红，绿，重构
  - 写一个测试用例
  - 运行测试
  - 写刚好能让测试通过的实现
  - 运行测试
  - 识别坏味道，用手法修改代码
  - 运行测试
* 写完，手动测试一下，基本没什么问题，有问题补个用例，修复
* 转测试，小问题，补用例，修复
* 代码整洁且用例齐全
* 重构，用手法消除代码里的坏味道
* 实践
  - 描述：产品代码的外部行为
  - 新功能：现有代码已有测试保证
  - 失败的：不满足于现状的诉求
  - 刚好：述求简练而有针对性
  - 一次只写一个：小步前进

## 原则

* 简单，只测试一个需求
* 符合 Given-When-Then 格式
* 速度快
* 包含断言
* 三大定律 Uncle Bob (Robert Martin)
  - You are not allowed to write any production code unless it is to make a failing unit test pass.不允许编写任何产品代码，除非目的是为了让失败的测试通过
  - You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures. 不允许编写多于一个的失败测试，编译错误也是失败
  - You are not allowed to write any more production code than is sufficient to pass the one failing unit test.不允许编写多于恰好能让测试通过的产品代码
* 防止过度设计

## Unit Test Skill

* 不能针对方法编写测试，而应根据业务编写测试用例。一个测试方法只能做一件事情，代表一个测试样本和一个业务规则
* Test Double 类型
  - Stub： 测试桩是用来接受SUT内部的间接输入（indirect inputs），并返回特定的值给SUT
  - Spy： Test Spy只负责获取内部情报，并把情报发出去，不负责验证情报的正确性
  - Mock： Mock Object和Test Spy有类似的地方，不同的是，Mock Object还负责对情报（intelligence）进行验证，总部（外部的测试案例）信任Mock Object的验证结果
  - Fake： 仅仅是用来替代一个实际的对象，并且拥有几乎和实际对象一样的功能，保证SUT能够正常工作。实际对象过分依赖外部环境，Fake Object可以减少这样的依赖
  - Dummy：Dummy Objects泛指在测试中必须传入的对象，而传入的这些对象实际上并不会产生任何作用，仅仅是为了能够调用被测对象而必须传入的一个东西
* 命名规则
  - should_not_charge_addition_fare_when_given_distance_is_less_than_base_meter
  - should_charge_addition_fare_when_given_distance_is_more_than_base_meter
* 从依赖的角度看,并不一定需要优先选择前序任务,因为我们可以使用 Mock 的方式驱动出当前任务需要依赖的接口,而不用考虑实现。
* 对于任务的重要性,主要是判断任务是否整个系统(模块)的核心功能。一个 判断标准是确定任务是功能的主要流程还是异常流程
* 从消费者的角度去思考用例
* 选择测试样本 (从易到难，高风险到低风险)

## Mock

* 依赖注入（DI）
* 面向接口设计，而不是面向实现
* 限制对外部的依赖
* 不要Mock私有方法，只Mock需要的方法
* 不要自欺欺人
* 什么时候使用

## Test

* 验收条件细化

## Drive

## 用例分析

* 从消费者的角度去思考用例
* 选择测试样本 (从易到难，高风险到低风险)，用数据来驱动（输入和输出）实现
* 驱动承担该职责的对象,根据意图设计接口
* 实例化需求： Given-When-Then

## Wirte Test first process - Red 需求澄清

* Given
  - 创建被测对象
  - initial input Object or Data
  - 思考它与其他对象的协作
* When
  - 思考被测接口的方法命名,以及它需要接收的传入参数
  - 考虑行为方式,究竟是命令式(verify)还是查询式(assert)方法
* Then
  - 驱动我们分析被测接口的返回值

## Test dirven implementation 实现与设计

* 测试通过：唯一目的
  - 失败的测试：实现新功能的时机
  - 刚好：简单、快捷、频繁验证
  - 不写任何额外的或无关的代码
* 原则
  - 最简单实现
  - 吝啬(结果导向)
  - 尽量少制造坏味道
  - 测试也是一个精打细算的过程
* 仅当Test Case达到2个或更多，并且第2个Case需要更一般化的解决方案时，才对代码实施一般化（泛化/抽象/模式）。

## 设计

* 简单设计 ，并不是没有设计
* 测试过程包括了需求分析和建模
* 测试驱动接口
* 重构，可以从无设计到简单设计，也可以从过度设计到简单设计

## 实践

* 掌握测试驱动开发的方法，练好基本功、改进工作方式，提高开发效率
* 测试前移
* 项目：
  - 要求
    + 代码整洁，没有重复代码
    + 有单元测试，单元测试覆盖率100%
    + 10分钟内完成
  - 技能点
    + JUnit单元测试
    + 测试驱动开发
    + IDEA快捷键
  - 能力目标
    + IDE的快捷键操作
    + 用JUnit编写单元测试
    + 编写失败的测试，驱动出产品代码
    + 充分利用代码生成
    + 刻意练习的节奏

## 重构

* 只在测试全部通过的前提下，做代码重构，或开始新加功能
  - 目前开始了的功能已被实现
  - 已有的产品代码已有测试保证
* 添加新功能与重构显然在同一时刻不共存(两顶帽子)
* 小步提交，随时可以停止

## 问题

* 不会合理拆分任务
* 不会写测试
* 不会写刚好的实现
* 不会重构
* 有没有Tasking?
  - 将一个原本的较大的需求，分解成一个个很小的需求,往往是非常容易的。通过这样的方式，可以缩短我们红绿重构的周期，得到快速的反馈
* 有没有选择最简单的Task先做？

## 实例

* 需求描述
  - Part A (总计 40 分) 首先,“羽毛球场管理系统”需要提供“询价”服务，当用户输入"How much?"的时候，系统应返回如下信息：
```
    ********Price********
    Welcome to badminton
    -------Workday-------
    9:00~12:00 30 yuan/h
    12:00~18:00 50 yuan/h
    18:00~20:00 80 yuan/h
    20:00~22:00 60 yuan/h
    -------Weekend-------
    9:00~12:00 40 yuan/h
    12:00~18:00 50 yuan/h
    18:00~22:00 60 yuan/h
    **Have a good day !**
```

  - 注意！价目表会实时变动，我们在文件 BadmintonDataLoader 中提供了函数 LoadWorkdayPriceList()和函数 LoadWeekendPriceList(),用来分别提供工作日和周末的价目表，当我修改价目表时程序仍需能正常工作。
  - 需求点/得分点
    + (5 分）能正确输出第一行、第二行和最后一行，如：
```
    ********Price********
    Welcome to badminton
    **Have a good day !**
```
    + (15 分）能正确输出 workday 部分，如：
```
    -------Workday-------
    9:00~12:00 30 yuan/h
    12:00~18:00 50 yuan/h
    18:00~20:00 80 yuan/h
    20:00~22:00 60 yuan/h
```
    + (10 分）能正确输出 weekend 部分，如：
```
    -------Weekend-------
    9:00~12:00 40 yuan/h
    12:00~18:00 50 yuan/h
    18:00~22:00 60 yuan/h
```
    + (10 分）能按正确的顺序打印以上三个部分
  - Part B (总计 60 分)同时系统需要提供预定场地的功能，当用户想预定场地时，需要告知系统用户ID、时间，以及场地号，因此用户向系统输入的格式为：Book {用户ID} {yyyy-MM-dd HH:mm~HH:mm} {场地编号} 例如：用户 0001 想预定 3 号场地，且时间为：2019 年 12 月 1 号 14:00 到 15:00 时，用户需要向系统输入以下信息：Book 0001 2019-12-01 14:00~15:00 3
    + 如果场地预定成功，那么系统会返回预定成功的提示以及所需费用。 例如：Success! You can use the No.3 court during 2019-12-11 14:00~15:00.
    + 为了保证系统正常运行，以下情况将会预定失败：
      - 预定时间不是整小时,指定场地在该时间段(部分或全部)已经被预定了
      - 预定结束时间早于开始时间，如：15:00 ～ 14:00
      - 预定的开始时间早于 9:00，如：8:00 ～ 10:00
      - 预定的结束时间晚于 22:00，如：20:00 ～ 23:00
      - 如果不幸预定失败，那么系统会返回失败提示：Sorry! Something wrong, please call the manager!
  - 需求点/得分点
    + (5 分) 假设预定成功，程序能打印出关键信息点：“success”, 场地编号, 预定的时间区间. 例如： Success! 3 2019/12/11 14 - 15
    + (15 分) 可以成功预定且程序打印出来的信息完全正确。
    + (6 分) 当预定时间不是整小时时，系统会返回失败提示。
    + (12 分) 当指定场地在该时间段(部分或全部)已经被预定了时，系统会返回失败提示。
    + (6 分) 当预定结束时间早于开始时间，如：15:00 ～ 14:00时，系统会返回失败提示。
    + (6 分) 当预定的开始时间早于 9:00，如：8:00 ～ 10:00时，系统会返回失败提示。
    + (6 分) 当预定的结束时间晚于 22:00，如：20:00 ～ 23:00时，系统会返回失败提示。
  - Part C (附加题,总分 50 分)为了方便客户，系统还需提供取消预定的功能，当用户想取消预定时，也需要告知系统用户ID、时间，以及场地号，相应的，用户向系统输入的格式为：Cancel {用户ID} {yyyy-MM-dd HH:mm~HH:mm} {场地编号}，例如：Cancel 0001 2019-12-11 14:00~15:00 3
    + 如果取消成功，那么系统会返回成功的提示：Cancel Success! Look forward to your next visit！
    + 假如取消的时候产生了违约金，系统返回的提示将变为：Cancel Success! You need pay 25 yuan as penalty. Look forward to your next visit！
    + 以下情况将会取消失败：
      - 取消预定时间不是整小时用户并没有预定指定场地的指定时间段(必须和预定时间段完全一致)
      - 当取消预定失败时，系统会返回失败提示：Sorry! Something wrong, please try again!
  - 需求点/得分点
    + (15 分) 可以取消成功，且不论是否产生违约金，程序能打印出:Cancel Success! Look forward to your next visit！
    + (15 分）可以取消成功，且产生了违约金，程序打印出来的信息完全正确。
    + (10 分）当预定时间不是整小时时，系统会返回失败提示。
    + (10 分)当用户并没有预定指定场地的指定时间段(必须和预定时间段完全一致)时，系统会返回失败提示。

## 图书

* 《测试驱动开发》Kent Beck
* Grow Object-Oriented Software Guided by Tests

## 工具

* Dbunit
* REst-Assusred
* [ SpectoLabs / hoverfly ](https://github.com/SpectoLabs/hoverfly):Lightweight service virtualization/API simulation tool for developers and testers https://hoverfly.io

## 参考

* [极限编程](http://www.extremeprogramming.cn)
* [eXtremeProgramming-cn/xp-gym-training](https://github.com/eXtremeProgramming-cn/xp-gym-training):Free open source training materials for eXtreme Programming practitioners and promoters
* [gigix/dojo-scaffold](https://github.com/gigix/dojo-scaffold):A Java/Gradle scaffold for coding dojos
